Tools
Yum:
sudo apt-get install yum
Telnet:
apt-get install telnet

run shell on container:
docker exec -it name /bin/bash

PAYING ACCOUNTS:
AWS:guy@plec-o.com
GOOGLE: guy@plec-o.com - old
pleco3007@shalev-family.com


Setup terraform:
configure terraform: https://registry.terraform.io/providers/hashicorp/google/latest/docs/guides/provider_reference
create service account: https://cloud.google.com/compute/docs/access/create-enable-service-accounts-for-instances
get the key of the service account
set the key to env:  $Env:GOOGLE_APPLICATION_CREDENTIALS += "$HOME/pleco/pleco1-d8536d6e553c"
Running Terraform outside of Google Cloud
If you are running terraform outside of Google Cloud, generate a service account key and set the GOOGLE_APPLICATION_CREDENTIALS environment variable to the path of the service account key. Terraform will use that key for authentication.

Disabling mtls authentication
mtls authentication will soon become enabled by default if your system supports it. To disable mtls authentication at any point set GOOGLE_API_USE_CLIENT_CERTIFICATE to false.

Install Docker
 curl -fsSL https://get.docker.com -o get-docker.sh
 sudo sh get-docker.sh

 sudo groupadd docker
 sudo usermod -aG docker ${USER}
 LOGOUT


Add to Firewall rule with all traffic

Install Kind
curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.11.1/kind-linux-amd64
chmod +x ./kind
mkdir bin
export PATH=$HOME/bin:$PATH
mv ./kind /$HOME/bin/kind
kind create cluster

Install kubectl
curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
sudo install -o root -g root -m 0755 kubectl $HOME/bin/kubectl

Hello world
kubectl apply -f https://k8s.io/examples/service/load-balancer-example.yaml
kubectl expose deployment hello-world --type=LoadBalancer --name=my-service
kubectl get services my-service

Install Metalib
kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/master/manifests/namespace.yaml
kubectl create secret generic -n metallb-system memberlist --from-literal=secretkey="$(openssl rand -base64 128)"
kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/master/manifests/metallb.yaml
kubectl get pods -n metallb-system --watch
#kubectl apply -f https://kind.sigs.k8s.io/examples/loadbalancer/metallb-configmap.yaml

cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: ConfigMap
metadata:
  namespace: metallb-system
  name: config
data:
  config: |
    address-pools:
    - name: default
      protocol: layer2
      addresses:
      - 172.18.255.200-172.18.255.250
EOF

docker pull guypleco/aws:lts
docker run -d -p 10.10.0.8:50051:50051 guypleco/aws:lts



changes to 2
Dynamic routing modeGlobal

# Check all possible clusters, as your .KUBECONFIG may have multiple contexts:
kubectl config view -o jsonpath='{"Cluster name\tServer\n"}{range .clusters[*]}{.name}{"\t"}{.cluster.server}{"\n"}{end}'

# Select name of cluster you want to interact with from above output:
export CLUSTER_NAME="gke_pleco1_us-central1_pleco1-gke"

# Point to the API server referring the cluster name
APISERVER=$(kubectl config view -o jsonpath="{.clusters[?(@.name==\"$CLUSTER_NAME\")].cluster.server}")

# Gets the token value
TOKEN=$(kubectl get secrets -o jsonpath="{.items[?(@.metadata.annotations['kubernetes\.io/service-account\.name']=='default')].data.token}"|base64 --decode)
echo $APISERVER
echo $TOKEN

# Explore the API with TOKEN
curl -X GET $APISERVER/api --header "Authorization: Bearer $TOKEN" --insecure